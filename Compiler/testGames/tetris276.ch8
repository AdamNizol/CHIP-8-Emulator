; Registers
; ---------
; V0 delay timer
; V1 free
; V2 free
; V3 free
; V4
; V5
; V6 x coord of shape
; V7 y coord of shape
; V8 dir of shape (1 = left, 2 = right, 3 = down)
; V9
; VA score
; VB
; VC
; VD will be used for key inputs
; VE used to determine current shape (1=T, 2=S, 3=reverseL, 4=L, 5=I, 6=Z)
; VF collision

; keyboard stuff for input later
; 123C		1234
; 456D	==>	qwer
; 789E		asdf
; A0BF		zxcv

; drawing stuff
; (0,0)		(63,0)
; (0,31) 	(63,31)


;THE ACTUAL GAME IS BELOW HERE
CLS

; init

LD I, border; set i to memory address of shape
LD V6  ,  29; set all shapes' initial x value to the middle (29)
LD V7, 0; set all shapes' initial y value to top (0)
LD V0, 27; set left border's x value
LD V1, 39; set right border's x value because this game of tetris played on 10 x 24 between pixels 28 and 38
LD V2, 0; set y value to 0 top of screen
LD V3, 31; set y value to 31 bottom of screen
LD V8, 3 ;initial direction of block is down
CALL drawVerticalBorder
CALL drawHorizBorder
jp gameLoop
RET

drawVerticalBorder
	DRW V1, V2, 1; draw right border
	DRW V0, V2, 1; draw left border
	ADD V2, 1; keep adding one to y value (drawing walls)
	SE V2,  V3; skip the jump if y value of the border is 31
	call drawVerticalBorder
	RET

drawHorizBorder
	DRW V0, V3, 1 ; draw horizontal border pixel
	ADD V0, 1 ; keep adding one to x location
	SE V0, V1
	call drawHorizBorder
	DRW V0, V3, 1; draws last corner pixel
	RET


; main game loop
gameLoop
	SNE VE, 1 ; if the block ID is 1, spawn Z block
	CALL drawZ
	SNE VE, 2 ; if block ID is 2, spawn L block
	CALL drawI
	SNE VE, 3 ; if block ID is 3, spawn reverse L block
	CALL drawReverseL
	SNE VE, 4 ; if block ID is 4, spawn L block
	CALL drawL
	SNE VE, 5 ; if block ID is not 5, spawn S block
	CALL drawS
	SNE VE, 6 ; if block ID is 6, spawn T block
	CALL drawT
	SNE VE, 7 ; if block ID is 6, loop back around to 1
	LD VE, 0
	SNE V7, 0; if the block (y val) is not at the top, dont have to change the block ID, otherwise, keep adding 1
	ADD VE, 1
	jp gameLoop

drawT
	LD I, shapeT; set I to memory address of shape
	CALL draw_shape
	RET

drawS
	LD I, shapeS; set I to memory address of shape
	CALL draw_shape
	RET

drawReverseL
	LD I, shapeReverseL; set I to memory address of shape
	CALL draw_shape
	RET

drawL
	LD I, shapeL; set I to memory address of shape
	CALL draw_shape
	RET

drawI
	LD I, shapeI; set I to memory address of shape
	CALL draw_shape
	RET

drawZ
	LD I, shapeZ; set I to memory address of shape
	CALL draw_shape
	RET

drawBlock
	SNE VE, 2 ;If it is an I block, draw it (needs more number of bytes to represent it)
	DRW V6, V7, 4 ; four into 30
	SE VE, 255 ; otherwise, draw the blocks (rest of block need the same number of bytes needed to represent it)
	DRW V6, V7, 3
	RET

; function to draw and update the position of the shape
draw_shape

	CALL getInput

	CALL drawBlock

	SNE VF, 1; check if there is a collision with another block or with the border
	CALL checkUndo ; if shape landed on something undo the collision and redraw on top

	SE V8, 3;if block dir is not down, set it to down
 	LD  V8,  3

	SNE VF, 1; check the collision
	RET

	;Delay
	LD V0, 5 ; load the value to delay by into the empty register (to pass to delay timer)
	LD DT, V0 ; pass the above value into the delay timer "register"
	call delay ; loops until delay timer is 0

	; erase the shape, move it, then redraw it at new position
	CALL drawBlock; erase the shape
	SNE V7, 30
	LD V7, 0 ;reset y val if it hits the bottom

	ADD V7, 1; add 1  y coord of shape - want to go striaght down



 	RET

undoDrop
	CALL drawBlock; undo mistake
	LD V1, 1
	SUB V7, V1; subtract 1 to go back up one

	CALL drawBlock; draw in right place
	SNE V8, 3
	LD V7, 0; set y value to top of screen
	SNE V8, 3
	LD V6, 29; set x value to middle
	RET

undoDropHoriz
	CALL drawBlock; undo mistake
	LD V1, 1
	SNE V8, 1 ;if the direction of shape is left
	ADD V6, 1 ;push back to the right
	SNE V8, 2 ;if the direction of shape is right
	SUB V6, V1 ;push back to the left

	CALL drawBlock; draw in right place
	RET

checkUndo
	CALL undoDropHoriz
	;SNE V8, 3
	CALL undoDrop
	;SNE V8, 1
	;CALL undoDropHoriz
	;SNE V8, 2
	;CALL undoDropHoriz
	RET
; get inputs from user
getInput

	LD VD, 4; put the key value into the register
	SKNP VD; check if the key value in the register was pressed, if not pressed, skip the call
	CALL moveLeft

	LD VD, 6; put the key value into the register
	SKNP VD; check if the key value in the register was pressed, if not pressed, skip the call
	CALL moveRight

	RET


moveLeft
	LD VD, 4; put the key value into the register
	LD V1, 1
	LD V8, 1; set block direction to left
	SUB V6, V1; move shape left
	RET

moveRight
	LD V8, 2;set block direction to right
	ADD V6, 1; move shape right
	RET

; function to delay the drawing of the shape
delay
	LD V0, DT ; get the value for the delay timer
	SE V0, 0 ; if the value of the "delay timer" is 0, skip the next instruction
	call delay ; jump to the start of the function, repeating until the delay timer is 0
	RET

;sprite data

border
	byte	%10000000
shapeT
	byte	%00010000
	byte	%00011000
	byte	%00010000
shapeS
	byte    %00010000
	byte 	%00011000
	byte    %00001000
shapeReverseL
	byte	%00010000
	byte	%00010000
	byte	%00110000
shapeL
	byte	%00010000
	byte	%00010000
	byte	%00011000
shapeI
	byte	%00100000
	byte	%00100000
	byte	%00100000
	byte	%00100000
shapeZ
	byte    %00001000
	byte 	%00011000
	byte    %00010000
