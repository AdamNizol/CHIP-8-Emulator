; Registers
; ---------
; V0
; V1 free
; V2 free
; V3 free
; V4
; V5
; V6 x coord of shape
; V7 y coord of shape
; V8 dir of shape (1 = left, 2 = right, 3 = down)
; V9
; VA score
; VB delay
; VC will be used for shape rotations
; VD will be used for key inputs
; VE used to determine current shape (1=T, 2=S, 3=reverseL, 4=L, 5=I, 6=Z)
; VF collision

; keyboard stuff for input later
; 123C		1234
; 456D	==>	qwer
; 789E		asdf
; A0BF		zxcv

; drawing stuff
; (0,0)		(63,0)
; (0,31) 	(63,31)


;THE ACTUAL GAME IS BELOW HERE
CLS
LD I, border; set i to memory address of shape
LD V6, 29; set all shapes' initial x value to the middle (29)
LD V7, 0; set all shapes' initial y value to top (0)
LD V0, 27; set left border's x value
LD V1, 39; set right border's x value because this game of tetris played on 10 x 24 between pixels 28 and 38
LD V2, 0; set y value to 0 top of screen
LD V3, 31; set y value to 31 bottom of screen
LD V8, 3;initial direction of block is down
LD VC, 1; init shape rotations
LD VB, 5 ; load the value to delay by into the empty register (to pass to delay timer)
LD DT, VB ; pass the above value into the delay timer "register"
CALL drawVerticalBorder
CALL drawHorizBorder

; main game loop
gameLoop

	SNE VE, 1 ; if the block ID is 1, spawn Z block
	CALL drawZ
	SNE VE, 2 ; if block ID is 2, spawn B block
	CALL drawB
	SNE VE, 3 ; if block ID is 3, spawn reverse L block
	CALL drawReverseL
	SNE VE, 4 ; if block ID is 4, spawn L block
	CALL drawL
	SNE VE, 5 ; if block ID is not 5, spawn S block
	CALL drawS
	SNE VE, 6 ; if block ID is 6, spawn T block
	CALL drawT
	SNE VE, 7 ; if block ID is 7, spawn I block
	CALL drawI
	SNE VE, 8 ; if block ID is 8, loop back around to 1
	LD VE, 1
	SNE V7, 0; if the block (y val) is not at the top, dont have to change the block ID, otherwise, keep adding 1
	ADD VE, 1
	CALL getInput
	SNE V7, 0
	LD VB, 0
	jp gameLoop
	RET

drawVerticalBorder
	DRW V1, V2, 1; draw right border
	DRW V0, V2, 1; draw left border
	ADD V2, 1; keep adding one to y value (drawing walls)
	SE V2, V3; skip the jump if y value of the border is 31
	jp drawVerticalBorder
	RET

drawHorizBorder
	DRW V0, V3, 1 ; draw horizontal border pixel
	ADD V0, 1 ; keep adding one to x location
	SE V0, V1
	jp drawHorizBorder
	DRW V0, V3, 1; draws last corner pixel
	RET



drawT
	;LD I, shapeT1; set I to memory address of shape
	SNE VC, 1
	LD I, shapeT1
	SNE VC, 2
	LD I, shapeT2
	SNE VC, 3
	LD I, shapeT3
	SNE VC, 4
	LD I, shapeT4
	CALL checkBlock
	RET

drawS
	;LD I, shapeS1; set I to memory address of shape
	SNE VC, 1
	LD I, shapeS1
	SNE VC, 2
	LD I, shapeS2
	CALL checkBlock
	RET

drawB
	LD I, shapeB
	CALL checkBlock
	RET

drawReverseL
	;LD I, shapeReverseL1; set I to memory address of shape
	SNE VC, 1
	LD I, shapeReverseL1
	SNE VC, 2
	LD I, shapeReverseL2
	SNE VC, 3
	LD I, shapeReverseL3
	SNE VC, 4
	LD I, shapeReverseL4
	CALL checkBlock
	RET

drawL
	;LD I, shapeL1; set I to memory address of shape
	SNE VC, 1
	LD I, shapeL1
	SNE VC, 2
	LD I, shapeL2
	SNE VC, 3
	LD I, shapeL3
	SNE VC, 4
	LD I, shapeL4
	CALL checkBlock
	RET

drawI
	;LD I, shapeI1; set I to memory address of shape
	SNE VC, 1
	LD I, shapeI1
	SNE VC, 2
	LD I, shapeI2
	CALL checkBlock

	RET

drawZ
	;LD I, shapeZ1; set I to memory address of shape
	SNE VC, 1
	LD I, shapeZ1
	SNE VC, 2
	LD I, shapeZ2
	CALL checkBlock
	RET

drawShape
	SNE VE, 7 ;If it is an I block, draw it (needs more number of bytes to represent it)
	DRW V6, V7, 4
	SE VE, 7 ; otherwise, draw the blocks (rest of block need the same number of bytes needed to represent it)
	DRW V6, V7, 3
	RET

; function to draw and update the position of the shape
checkBlock

	CALL drawShape

	SNE VF, 1; check if there is a collision with another block or with the border
	CALL checkUndo ; if shape landed on something undo the collision and redraw on top

	SE V8, 3;if block dir is not down, set it to down
 	LD V8, 3

	SNE VF, 1; check the collision
	RET


	;Delay
	SE VB, 1
	CALL initDelay

	; erase the shape, move it, then redraw it at new position
	CALL drawShape; erase the shape
	SNE V7, 31
	LD V7, 0 ;reset y val if it hits the bottom
	SNE V7, 31
	LD VC, 1

	ADD V7, 1; add 1  y coord of shape - want to go striaght down
 	RET

undoDrop
	CALL drawShape; undo mistake
	LD V1, 1
	SUB V7, V1; subtract 1 to go back up one

	CALL drawShape; draw in right place
	SNE V8, 3
	LD V7, 0; set y value to top of screen
	SNE V8, 3
	LD V6, 29; set x value to middle
	RET

undoDropHoriz
	CALL drawShape; undo mistake
	LD V1, 1
	SNE V8, 1 ;if the direction of shape is left
	ADD V6, 1 ;push back to the right
	SNE V8, 2 ;if the direction of shape is right
	SUB V6, V1 ;push back to the left
	CALL drawShape; draw in right place
	RET

checkUndo
	CALL undoDropHoriz
	;SNE V8, 3;if dir is down, must have fallen on top of another block
	CALL undoDrop
	;SE V8, 3; if dir is left/right, the player is trying to move the current block into another one
	;CALL undoDropHoriz
	RET

; get inputs from user
getInput

	LD VD, 4; put the key value into the register
	SKNP VD; check if the key value in the register was pressed, if not pressed, skip the call
	CALL moveLeft

	LD VD, 6; put the key value into the register
	SKNP VD; check if the key value in the register was pressed, if not pressed, skip the call
	CALL moveRight

	LD VD, 5; rotate the shape
	SKNP VD
	CALL rotateShape

	LD VD, 8
	SKNP VD
	LD VB, 1
	RET

moveLeft
	LD VD, 4; put the key value into the register
	LD V1, 1
	LD V8, 1; set block direction to left
	SUB V6, V1; move shape left
	RET

moveRight
	LD V8, 2;set block direction to right
	ADD V6, 1; move shape right
	RET

rotateShape
	SNE VE, 1
	CALL rotateZ
	SNE VE, 3
	CALL rotateReverseL
	SNE VE, 4
	CALL rotateL
	SNE VE, 5
	CALL rotateS
	SNE VE, 6
	CALL rotateT
	SNE VE, 7
	CALL rotateI
	RET

rotateT
	DRW V6, V7, 3
	ADD VC, 1
	SNE VC, 5
	LD VC, 1
	CALL drawShape
	CALL drawT
	RET
rotateS
	DRW V6, V7, 3
	ADD VC, 1
	SNE VC, 3
	LD VC, 1
	CALL drawShape
	CALL drawS
	RET
rotateReverseL
	DRW V6, V7, 3
	ADD VC, 1
	SNE VC, 5
	LD VC, 1
	CALL drawShape
	CALL drawReverseL
	RET
rotateL
	DRW V6, V7, 3
	ADD VC, 1
	SNE VC, 5
	LD VC, 1
	CALL drawShape
	CALL drawL
	RET
rotateI
	DRW V6, V7, 4
	ADD VC, 1
	SNE VC, 3
	LD VC, 1
	CALL drawShape
	CALL drawI
	RET
rotateZ
	DRW V6, V7, 3
	ADD VC, 1
	SNE VC, 3
	LD VC, 1
	CALL drawShape
	CALL drawZ
	RET

initDelay
	LD V0, 5 ; load the value to delay by into the empty register (to pass to delay timer)
	LD DT, V0 ; pass the above value into the delay timer "register"
	CALL delay ; loops until delay timer is 0
	RET

; function to delay the drawing of the shape
delay
	LD VB, DT ; get the value for the delay timer
	SE VB, 0 ; if the value of the "delay timer" is 0, skip the next instruction
	JP delay; jump to the start of the function, repeating until the delay timer is 0
	LD VB, 0
	RET

;sprite data

border
	byte	%10000000
shapeT1
	byte	%00010000
	byte	%00011000
	byte	%00010000
shapeT2
	byte	%00010000
	byte	%00111000
	byte	%00000000
shapeT3
	byte	%00010000
	byte	%00110000
	byte	%00010000
shapeT4
	byte	%00000000
	byte	%00111000
	byte	%00010000
shapeB
	byte    %00000000
	byte	%00011000
	byte	%00011000
shapeS1
	byte    %00010000
	byte 	%00011000
	byte    %00001000
shapeS2
	byte	%00001100
	byte	%00011000
	byte	%00000000
shapeReverseL1
	byte	%00010000
	byte	%00010000
	byte	%00110000
shapeReverseL2
	byte	%00100000
	byte	%00111000
	byte	%00000000
shapeReverseL3
	byte	%00011000
	byte	%00010000
	byte	%00010000
shapeReverseL4
	byte	%00011100
	byte	%00000100
	byte	%00000000
shapeL1
	byte	%00010000
	byte	%00010000
	byte	%00011000
shapeL2
	byte	%00001000
	byte	%00111000
	byte	%00000000
shapeL3
	byte	%00110000
	byte	%00010000
	byte	%00010000
shapeL4
	byte	%00011100
	byte	%00010000
	byte	%00000000
shapeI1
	byte	%00100000
	byte	%00100000
	byte	%00100000
	byte	%00100000
shapeI2
	byte	%00000000
	byte	%00111100
	byte	%00000000
	byte	%00000000
shapeZ1
	byte    %00001000
	byte 	%00011000
	byte    %00010000
shapeZ2
	byte    %00110000
	byte 	%00011000
	byte    %00000000
