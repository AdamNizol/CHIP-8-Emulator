; Registers
; ---------
; V0 free
; V1 free
; V2 free
; V3 free
; V4 
; V5 x 
; V6 x coord of shape
; V7 y coord of shape
; V8 x dir of shape
; V9 y dir of shape
; VA score
; VB
; VC
; VD
; VE used to determine most current shape (1=T, 2=S, 3=reverseL, 4=L, 5=I, 6=Z)
; VF collision

; keyboard stuff for input later
; 123C		1234
; 456D	==>	qwer
; 789E		asdf
; A0BF		zxcv

; drawing stuff
; (0,0)		(63,0)
; (0,31) 	(63,31)


;THE ACTUAL GAME IS BELOW HERE

; init
Init
	LD I, border; set i to memory address of shape
	LD V6, 29; set all shapes' initial x value to the middle (29) 
	LD V7, 0; set all shapes' initial y value to top (0)
	LD V0, 27; set left border's x value
	LD V1, 39; set right border's x value because this game of tetris played on 10 x 24 between pixels 28 and 38
	LD V2, 0; set y value to 0 top of screen
	LD V3, 31; set y value to 31 bottom of screen
	call drawVerticalBorder
	call drawHorizBorder
	jp gameLoop
	RET

drawVerticalBorder
	DRW V1, V2, 1; draw left border
	DRW V0, V2, 1; draw right border
	ADD V2, 1; keep adding one to y value
	SE V2, V3; skip the jump if y value of the border is 31
	jp drawVerticalBorder
	RET

drawHorizBorder
	DRW V0, V3, 1
	ADD V0, 1
	SE V0, V1
	jp drawHorizBorder
	DRW V0, V3, 1; draws last corner pixel
	RET


; main game loop
gameLoop
	SNE VE, 1
	call drawZ
	SNE VE, 3
	call drawReverseL
	SNE VE, 4
	call drawL
	SNE VE, 5
	call drawS
	SNE VE, 6
	call drawT
	SNE VE, 6
	LD VE, 1
	SNE V7, 0; if the block (y val) is not at the top, dont have to change the block ID
	ADD VE, 1
	jp gameLoop

drawT
	LD I, shapeT; set I to memory address of shape
	call draw_shape
	RET

drawS
	LD I, shapeS; set I to memory address of shape
	call draw_shape
	RET

drawReverseL
	LD I, shapeReverseL; set I to memory address of shape
	call draw_shape
	RET

drawL
	LD I, shapeL; set I to memory address of shape
	call draw_shape
	RET

drawI
	LD I, shapeI; set I to memory address of shape
	call draw_shape
	RET

drawZ
	LD I, shapeZ; set I to memory address of shape
	call draw_shape
	RET

; function to draw and update the position of the shape
draw_shape
	
	LD VF, 0 ;set vf to zero so we can detect collisions

	DRW V6, V7, 3

	SNE VF, 1; check if the collision
	call undoDrop ; if shape landed on something undo the collision and redraw on top
	
	SNE VF, 1; check the collision
	RET

	;Delay
	LD V0, 5 ; load the value to delay by into the empty register (to pass to delay timer)
	LD DT, V0 ; pass the above value into the delay timer "register"
	CALL delay ; loops until delay timer is 0

	; erase the shape, move it, then redraw it at new position
	DRW V6, V7, 3; erase the shape
	ADD V7, 1; add 1 to the y dir of shape to y coord of shape ;want to go striaght down
 	
 	RET

undoDrop
	DRW V6, V7, 3; undo mistake
	LD V8, 1
	SUB V7, V8; subtract 1 to go back up one
	DRW V6, V7, 3; draw in right place
	LD V7, 0; set y value to top of screen
	RET
	

; function to delay the drawing of the shape
delay
	LD V0, DT ; get the value for the delay timer
	SE V0, 0 ; if the value of the "delay timer" is 0, skip the next instruction
	JP delay ; jump to the start of the function, repeating until the delay timer is 0
	RET


border
	byte	%10000000
shapeT
	byte	%00010000
	byte	%00011000
	byte	%00010000
shapeS
	byte    %00010000
	byte 	%00011000
	byte    %00001000
shapeReverseL
	byte	%00010000
	byte	%00010000
	byte	%00110000
shapeL
	byte	%00010000
	byte	%00010000
	byte	%00011000
shapeI
	byte	%00000000
	byte	%00000000
	byte	%00111100
shapeZ
	byte    %00001000
	byte 	%00011000
	byte    %00010000