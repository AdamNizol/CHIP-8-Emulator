; Registers
; ---------
; V0 empty
; V1 empty
; V2 empty
; V3 empty
; V4 x coord of score
; V5 y coord of score
; V6 x coord of ball
; V7 y coord of ball
; V8 x dir of ball
; V9 y dir of ball
; VA score
; VB x coord of left paddle
; VC y coord of left paddle
; VD x Coord of right paddle
; VE Y coord of right paddle
; VF collision

; initialize
CLS
LD i, ball; set i to memory address of ball
LD V6, 32; set initial x value to 32 (mid-way)
LD V7, 16; set initial y value to 16 (mid-way)
LD V8, 1; set initial x dir to 1 (right)
LD V9, 1; set initial y dir to 1 (down)
LD VB, 2 ; set init x coord of left paddle
LD VC, 14 ; set init y coord of left paddle
LD VD, 61 ; set init x coord of right paddle
LD VE, 14 ; set init y coord of right paddle
DRW V6, V7, 1; draw the ball
LD i, paddle ;  set i to memory address of ball
DRW VB, VC, 6; draw the left paddle
DRW VD, VE, 6; draw the right paddle


; main loop
main_loop
	
	; paddle stuff
	LD i, paddle
	SE VC, 0; if the paddle is at the top, don't let the user move the paddle up
	CALL getLeftPadUpInput

	SE VC, 26; if the paddle is at the bottom, don't let the user move the paddle down
	CALL getLeftPadDownInput

	SE VE, 0; if the paddle is at the top, don't let the user move the paddle up
	CALL getRightPadUpInput

	SE VE, 26; if the paddle is at the bottom, don't let the user move the paddle down
	CALL getRightPadDownInput

	; ball stuff
	LD i, ball
	; move the ball
	DRW V6, V7, 1; Draw (erase) ball
	ADD V6, V8; get next x coord
	ADD V7, V9; get next y coord
 	DRW V6, V7, 1; Draw ball

 	SNE VF, 1
 	CALL undo_ball_move;

	; handle collisions with the walls of the screen
	SNE V7, 0; check if ball is at top
	LD V9, 1; change y dir of ball 

	SNE V7, 31; check if ball is at bottom
	LD V9, -1; change y dir of ball

	SNE V6, 63; check if ball is at right
	LD V8, -1; CHANGE THIS FOR CALLING POINTS

	SNE V6, 0; check if ball is at left
	LD V8, 1; CHANGE THIS FOR CALLING POINTS

	jp main_loop

; if the ball ends up in the paddle, this moves the ball and sets its direction to the appropriate direction based on the collision
undo_ball_move
	DRW V6, V7, 1
	SUB V6, V8
	SUB V7, V9
	DRW V6, V7, 1
	SE V8, 1
	call leftToRight
	SE V8, -1
	call rightToLeft
	RET

leftToRight
	LD V8, 1
	LD V1, 1;
	RET

rightToLeft
	SE V1, 1
	LD V8, -1
	LD V1, 0
	RET

getLeftPadUpInput
	LD V0, 1; put the key value into the register
	SKP V0; if the key is pressed, move the paddle before returning
	RET
	; moveLeftPadUp
	DRW VB, VC, 6
	ADD VC, -2
	DRW VB, VC, 6
	RET

getLeftPadDownInput
	LD V0, 4; put the key value into the register
	SKP V0; if the key is pressed, move the paddle before returning
	RET
	; moveLeftPadDown
	DRW VB, VC, 6
	ADD VC, 2
	DRW VB, VC, 6
	RET

getRightPadUpInput
	LD V0, 12; put the key value into the register
	SKP V0; if the key is pressed, move the paddle before returning
	RET
	; moveRightPadUp
	DRW VD, VE, 6
	ADD VE, -2
	DRW VD, VE, 6
	RET

getRightPadDownInput
	LD V0, 13; put the key value into the register
	SKP V0; if the key is pressed, move the paddle before returning
	RET
	; moveRightPadDown
	DRW VD, VE, 6
	ADD VE, 2
	DRW VD, VE, 6
	RET





; function to delay the drawing of the ball
delay
	LD V0, DT ; get the value for the delay timer
	SE V0, 0 ; if the value of the "delay timer" is 0, skip the next instruction
	JP delay; jump to the start of the function, repeating until the delay timer is 0
	RET

ball
	byte 	%10000000

paddle
	byte	%10000000
	byte	%10000000
	byte	%10000000
	byte	%10000000
	byte	%10000000
	byte	%10000000





