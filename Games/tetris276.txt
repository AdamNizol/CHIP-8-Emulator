; Registers
; ---------
; V0 empty
; V1 empty
; V2 empty
; V3 empty
; V4 
; V5 
; V6 x coord of shape
; V7 y coord of shape
; V8 x dir of shape
; V9 y dir of shape
; VA score
; VB x coord of left paddle
; VC y coord of left paddle
; VD x Coord of right paddle
; VE Y coord of right paddle
; VF collision

; keyboard stuff for input later
; 123C		1234
; 456D	==>	qwer
; 789E		asdf
; A0BF		zxcv

; directional stuff
;	-1
;-1	 o	1
;	 1

; drawing stuff
; (0,0)		(63,0)
; (0,31) 	(63,31


;THE ACTUAL GAME IS BELOW HERE

; init

LD i, zed; set i to memory address of shape
LD V6, 32; set initial x value to 32 (mid-way)
LD V7, 0; set initial y value to 16 top of screen
LD V8, 1; undo drop if collion with another shape
LD V9, 1; set initial y dir to 1 (down)


; main game loop
loop	
	call draw_shape
	jp loop

; function to draw and update the position of the shape
draw_shape
	
	LD VF, 0 ;set vf to zero so we can detect collisions

	; draw	
	DRW V6, V7, 3; draw the shape

	SNE VF, 1; check if the collion
	call undoDrop ; if shape landed on something undo the collison and redraw on top
	
	SNE VF, 1; check if the collion, 
	RET



	;Delay
	LD V0, 9 ; load the value to delay by into the empty register (to pass to delay timer)
	LD DT, V0 ; pass the above value into the delay timer "register"
	CALL delay ; loops until delay timer is 0

	; erase the shape, move it, then redraw it at new position
	DRW V6, V7, 3; erase the shape
	;ADD V6, V8; add the x dir of shape to x coord of shape
	ADD V7, V9; add the y dir of shape to y coord of shape ;want to go striaght down
 	
	

	; handle collisions with the bottom wall

	; if the shape is at the bottom of the screen, change y dir to 0, so the shape stop at bottom
	SNE V7, 29; check if the y value of the shape is 29 (bottom), skip next if not 31
	DRW V6, V7, 3; draw the shape

	; if the shape is at bottom of the screen, change y value to 0, so the shape can start at top
	SNE V7, 29; check if the y value of the shape is 31 (bottom), skip next if not 31
	LD V7, 0; set initial y value to 0 top of screen


	RET
;function
undoDrop
	DRW V6, V7, 3; undo mistake
	SUB V7, V8; add -1, go back up one
	DRW V6, V7, 3; draw in righ place
	LD V7, 0; set initial y value to 16 top of screen
	RET
	

; function to delay the drawing of the shape
delay
	LD V0, DT ; get the value for the delay timer
	SE V0, 0 ; if the value of the "delay timer" is 0, skip the next instruction
	JP delay ; jump to the start of the function, repeating until the delay timer is 0
	RET
	
	


; commands useful for user_input:
; SKP Vx
;	skip next instruction if key with the value of Vx is pressed
;	checks the keyboard, and if the key corresponding tot he value of Vx is currently in the down position, PC is increase by 2
; SKNP Vx
;	skip next instruction if key with the value of Vx is NOT pressed
;	checks the keyboard, and if the key corresponding to the value of Vx is currently in the up posisition, PC is increased by 2
; LD Vx, byte
;	Set Vx = kk (put value kk into register Vx)
;	use one of the empty registers to take input


zed
	byte    %00001000
	byte 	%00011000
	byte    %00010000