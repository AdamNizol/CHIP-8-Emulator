; Registers
; ---------
; V0 x coord left border    (reuse this after drawing borders)
; V1 x coord right border
; V2 y value of shape spawn to 0
; V3 bottom of screen
; V4 
; V5 
; V6 x coord of shape
; V7 y coord of shape
; V8 x dir of shape
; V9 y dir of shape
; VA score
; VB counting all pixels of a line to see if its a completed line (havent implemented)
; VC x coord of line that is being deleted (havent implemented)
; VD
; VE used to determine most current shape (1=T, 2=S, 3=reverseL, 4=L, 5=I, 6=Z)
; VF collision

; keyboard stuff for input later
; 123C		1234
; 456D	==>	qwer
; 789E		asdf
; A0BF		zxcv

; drawing stuff
; (0,0)		(63,0)
; (0,31) 	(63,31)


;THE ACTUAL GAME IS BELOW HERE
CLS
; init
Init
	LD I, border; set i to memory address of shape
	LD V6, 29; set all shapes' initial x value to the middle (29) 
	LD V7, 0; set all shapes' initial y value to top (0)
	LD V0, 27; set left border's x value
	LD V1, 39; set right border's x value because this game of tetris played on 10 x 24 between pixels 28 and 38
	LD V2, 0; set y value to 0 top of screen
	LD V3, 31; set y value to 31 bottom of screen
	call drawVerticalBorder
	call drawHorizBorder

	;***FOR TESTING DELETE THIS SECTION***

	LD V0, 28 ; make line start right after left wall
	LD V3, 30 ;make line one higher from previous line
	LD V1, 39 ; stop drawing right before right wall
	call drawLines
	;adjust line and draw another one
	LD V0, 28 ; make line start right after left wall
	LD V3, 29; move up one line
	call drawLines
	;*****DELETE THIS^^^^ ******

	jp gameLoop
	RET

;METHOD FOR TESTING DELETE THIS
drawLines
	DRW V0, V3, 1 ; draw horizontal border pixel
	ADD V0, 1 ; keeping adding one to x location
	SE V0, V1; skip the jump if y value of the border is 31
	jp drawLines
	RET

drawVerticalBorder
	DRW V1, V2, 1; draw right border
	DRW V0, V2, 1; draw left border
	ADD V2, 1; keep adding one to y value (drawing walls)
	SE V2, V3; skip the jump if y value of the border is 31
	jp drawVerticalBorder
	RET

drawHorizBorder
	DRW V0, V3, 1 ; draw horizontal border pixel
	ADD V0, 1 ; keep adding one to x location
	SE V0, V1
	jp drawHorizBorder
	DRW V0, V3, 1; draws last corner pixel
	RET


; main game loop
gameLoop
	
	SNE VE, 1 ; if the block ID is 1, spawn Z block
	call drawZ
	SNE VE, 2 ; if block ID is 2, spawn L block 
	call drawI
	SNE VE, 3 ; if block ID is 3, spawn reverse L block
	call drawReverseL
	SNE VE, 4 ; if block ID is 4, spawn L block
	call drawL
	SNE VE, 5 ; if block ID is not 5, spawn S block
	call drawS
	SNE VE, 6 ; if block ID is 6, spawn T block
	call drawT

	SNE VE, 6 ; if block ID is 6, loop back around to 1
	LD VE, 1
	SNE V7, 0; if the block (y val) is not at the top, dont have to change the block ID, otherwise, keep adding 1
	ADD VE, 1
	jp gameLoop

drawT
	LD I, shapeT; set I to memory address of shape
	call draw_shape
	RET

drawS
	LD I, shapeS; set I to memory address of shape
	call draw_shape
	RET

drawReverseL
	LD I, shapeReverseL; set I to memory address of shape
	call draw_shape
	RET

drawL
	LD I, shapeL; set I to memory address of shape
	call draw_shape
	RET

drawI
	LD I, shapeI; set I to memory address of shape
	call draw_shape
	RET

drawZ
	LD I, shapeZ; set I to memory address of shape
	call draw_shape
	RET

drawBlock
	SNE VE, 2 ;If it is an I block, draw it (needs more number of bytes to represent it)
	DRW V6, V7, 4
	SE VE, 2 ; otherwise, draw the blocks (rest of block need the same number of bytes needed to represent it)
	DRW V6, V7, 3
	RET

; function to draw and update the position of the shape
draw_shape
	
	call drawBlock

	SNE VF, 1; check if there is a collision with another block or with the border
	call undoDrop ; if shape landed on something undo the collision and redraw on top
	
	SNE VF, 1; check the collision
	RET

	;Delay
	LD V0, 5 ; load the value to delay by into the empty register (to pass to delay timer)
	LD DT, V0 ; pass the above value into the delay timer "register"
	CALL delay ; loops until delay timer is 0

	; erase the shape, move it, then redraw it at new position
	call drawBlock; erase the shape
	ADD V7, 1; add 1  y coord of shape - want to go striaght down
 	
 	RET
; function undo if there is a collision after each collion check 
undoDrop ;FIX THIS SO THAT IT UNDO'S MOVES INTO WALL. IT SHOULD NOT SET Y VALUE TO 0
	call drawBlock; undo mistake
	LD V8, 1 ; set up V8 register
	SUB V7, V8; subtract 1 to go back up one
	call drawBlock; draw in right place
	LD V7, 0; set y value to top of screen
	;after collion undo check all lines if any line is completed
	;***NEW CODE HERE***
	LD VC, 30 ;start at bottom line and work your way up. Or do the opposite????
	
	call loopToIterateOverAllLines
	RET
	

; function to delay the drawing of the shape
delay
	LD V0, DT ; get the value for the delay timer
	SE V0, 0 ; if the value of the "delay timer" is 0, skip the next instruction
	JP delay ; jump to the start of the function, repeating until the delay timer is 0
	RET
; function to loop through lines bottom to top and call deleteFullLinesOnly function
loopToIterateOverAllLines ; 30 to 0
	
	LD V0, 24 ; make line check start right after left wall
	LD V1, 35; end at right wall
	LD VB, 0 ; reset pixels count in a line to 0
	call checkIfFullLine ; see if that line is full
	SUB VC, V8 ; check next line

	SE VC, 0; skip the jump if x value of V0 is 31
	jp loopToIterateOverAllLines


	LD VF, 1 
	RET

; function for testing if horizontal line at register VC is a complete line
checkIfFullLine
	LD VF,0 ; reset vf flag
	DRW V0, VC, 1 ; draw horizontal border pixel
	;check vf flag
	SNE VF, 1;  if vf flagged then ..
	ADD VB, 1 ; add one to pixel count in a line
	;redraw after checking if pixel is there for the count
	DRW V0, VC, 1 ;
	
	ADD V0, 1 ; keeping adding one to x location
	SE V0, V1; skip the jump if x value of V0 is 31
	jp checkIfFullLine
	
	;before exiting this method check if line was complete =11
	;if line count is equal to full line then
	SNE VB,11; if full line found reset V0 to delete that line
	LD V0, 24;
	SNE VB, 11; now we are going to delete that line
	call deleteLine


	RET
; function delete line at VC
deleteLine
	DRW V0, VC, 1 ; deleting line one pixel at a time
	ADD V0, 1 ; keeping adding one to x location
	SE V0, V1; skip the jump if y value of the border is 31
	jp deleteLine
	;CALLL MOVE EVERYTHING DOWN 
	RET
	


; -------sprite data------

border
	byte	%10000000
shapeT
	byte	%00010000
	byte	%00011000
	byte	%00010000
shapeS
	byte    %00010000
	byte 	%00011000
	byte    %00001000
shapeReverseL
	byte	%00010000
	byte	%00010000
	byte	%00110000
shapeL
	byte	%00010000
	byte	%00010000
	byte	%00011000
shapeI
	byte	%00100000
	byte	%00100000
	byte	%00100000
	byte	%00100000
shapeZ
	byte    %00001000
	byte 	%00011000
	byte    %00010000
